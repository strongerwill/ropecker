/*************************************************************************
  > File Name: pagefault_syscall.c
  > Author: Yueqiang Cheng
  > Mail: strongerwill@gmail.com 
  > Created Time: Sat 15 Sep 2012 03:48:49 PM EDT
 ************************************************************************/

#include <linux/module.h>
#include <linux/kernel.h>   /* Needed for KERN_INFO, we're doing kernel work */
#include <asm/page.h>		/* PAGE_SIZE			*/
#include <asm/irq_vectors.h>/* NR_VECTORS 256		*/
#include <asm/segment.h>    /* __USER_DS and __USER_CS*/
//#include <asm/system.h>		/* read_cr3				*/
#include <linux/mman.h>		/* mmap2, PROT_EXEC		*/
#include <asm/tlbflush.h>	/* flush_tlb_all		*/

/* Added by Zongwei Zhou for copy_from_user */
#include <asm/uaccess.h>

#include "debug.h"
#include "kern_idt.h"
#include "branchdb.h"
#include "lbr.h"
#include "data_struct.h"
#include "monwin.h"
#include "payload_checking.h"
#include "stack_check.h"


static ulong orig_page_fault = 0;

ulong g_exp_irq_esp = 0;
ulong g_error_code = 0;

ulong orig_mprotect = 0;
ulong orig_mmap2 = 0;
ulong orig_munmap = 0;
ulong orig_execve = 0;
ulong orig_clone = 0;
ulong orig_fork = 0;
ulong orig_open = 0;
ulong orig_close = 0;
ulong orig_exit_group = 0;

monitor_app_t apps[MAX_MONITOR_NUM];
char* monitor_app_list[MAX_APP_LIST_NUM];

extern void page_fault_14(void); 
const static ulong pre_handle_exception_code = (ulong) &pre_handle_exception;
const static ulong post_handle_exception_code = (ulong) &post_handle_exception;

#ifdef MICRO_BENCHMARK
unsigned long long start = 0, end = 0, start2=0, end2=0, start3=0, end3=0;
#endif

/**
 * TODO list:
 * 1) Instruction Emulation (Yueqiang)
 * 2) Multi-process support (Yueqiang)
 * 3) Algorithm Update (Yueqiang, Miao, Zongwei)
 *    past execution trace in LBR, future execution flow in the payload detection
 *    if they are chained, and the length is larger than the threshold, it is a ROP attack
 *    if not chained, whether to remember the chaining number(multi-page window)
 * 4) Security Discussion
 *    gadget chain < threshold (e.g., call sensitive syscalls)
 *    no sensitive syscalls(e.g., modify important data structure)
 *    aligned gadgets
 *    ARM arch(e.g., aligned?, LBR?, emulation difficulty, disassembling difficulty)
 * 5) offline table?? (appendix?)
 *
 * Experiments:
 * 1) The length of the gadget chain
 *       the length of ROP payload (generated by Q) (done)
 *       the length of normal applications (fuzzing tools?)
 * 2) sensitive syscalls
 *       gadget chain threshold? in normal application
 * 3) multi-page window threshold
 * 4) SPEC CINT2006
 * 5) Apache performance evaluation (multi-process)
 * 6) Single Process (large application, bad code locality, common tools, serialized )
 *       Apache single process mode?????
 *       simulator (ARM), JVM
 * 7) ROP payload with only aligned gadgets (done)
 * 8) Micro Benchmark (system call interception, exception interception) (done)
 **/

static inline ulong verify_mprotect_request(ulong procid, struct pt_regs* regs){
	ulong ret = rop_check(procid, regs);
	// if rop check passes, return true to show the verification is good
	if(!ret) return 1;
	return 0;
}

/**
 * replace the sys_mprotect syscall handler
 * if the "prot" flag contains the PROT_EXEC,
 * we should do stack_checking
 **/
asmlinkage long rop_mprotect(ulong start, size_t len, ulong prot){
	long ret = 0;
	MPROTECT_FN fn = (MPROTECT_FN)orig_mprotect;
	ulong procid = current->pid;

	// we should verify the mprotect request before pass it to the kernel
	if( is_monitor_app_by_id(procid) ){
		//ROP_DB(printk(KERN_INFO "in the mprotect handler %08lx, len %d prot %08lx\n", start, len, prot ));
		// set monitor window on the start point of the app
		if( (prot & PROT_EXEC) != 0 && !verify_mprotect_request(procid, (struct pt_regs*)&start)){
			printk(KERN_INFO "there is ROP in the target application [%s]", get_app_slot(procid)->name);
		}
	}
	// call original handler
	ret = fn(start, len, prot);
	return ret;	
}

/**
 * replace the sys_munmap syscall handler
 * if the addr is the share library base address,
 * we should release it and update the table in the kernel
 **/
asmlinkage long rop_munmap(ulong addr, ulong len){
	long ret = 0;
	MUNMAP_FN fn = (MUNMAP_FN)orig_munmap;
	ulong procid = current->pid;

	// call orignal handler
	ret = fn(addr, len);
	// update the mapping table, remove the corresponding element
	if(is_monitor_app_by_id(procid)){
		//ROP_DB(printk(KERN_INFO "in the munmap handler %08lx, len %ld\n", addr, len));
		remove_mapping_element(get_app_slot(procid), addr, len);
		// unregister code section for payload checking
		unregister_code_region(procid, (void*)addr);
	}
	return ret;
}

/**
 * replace the sys_mmap2 syscall handler
 * if the "prot" flag contains the PROT_EXEC
 * we should do stack checking
 **/
asmlinkage long rop_mmap2(ulong addr, ulong len, ulong prot, ulong flags, ulong fd, ulong pgoff){
	long ret = 0;
	ulong procid = current->pid;
	MMAP2_FN fn = (MMAP2_FN)orig_mmap2;

	// call orignal handler
	ret = fn(addr, len, prot, flags, fd, pgoff);
	// insert the new element into the mapping table
	if( is_monitor_app_by_id(procid) && (prot & PROT_EXEC) != 0 && (((long)fd) > 0)){
		monitor_app_t *slot = get_app_slot(procid);
		mapping_element_t *ptr_ele = NULL; 
		char* filename = get_filename_by_fd(slot, fd);
	//ROP_DB(printk(KERN_ERR "in the mmap2 handler %08lx, len %lx, prot %08lx, addr %08lx, exe %08x\n", addr, len, prot, ret, PROT_EXEC));
		if(filename == NULL) {
			printk(KERN_ERR "the mmap file is not open, there may be an attack\n");
			goto out;
		}
		ptr_ele = insert_element(slot, ret, len);
		install_db(ptr_ele, filename);
		// register the code section for payload checking
		//register_code_region(procid, (void*)ret, (void*)(ret + len));
		ptr_ele->end = ptr_ele->start + ((db_des_p)(ptr_ele->db_des))->odb.size * 2;
		register_code_region(procid, (void*)ret, (void*)(ptr_ele->end));

	}
out:
	return ret;
}

/**
 * replace the sys_open syscall handler
 * if the flag contains O_CLOEXEC, we will record the fd
 **/
asmlinkage long rop_open(const char __user *name, int flags, int mode){
	long ret = 0;
	OPEN_FN fn = (OPEN_FN)orig_open;
	ulong procid = current->pid;

	// call orignal handler
	ret = fn(name, flags, mode);
	// record the pair {fd, filename} of the new file if the flag contains O_CLOEXEC (0x00080000)
	if( (flags & O_CLOEXEC) != 0 && is_monitor_app_by_id(procid) ){
		//ROP_DB(printk(KERN_INFO "in the open handler name: %s, flag %08x mode %08x, O_CLOEXEC %08X\n", name, flags, mode, O_CLOEXEC));
		save_pair(get_app_slot(procid), get_name_from_path(name), ret);
	}
	return ret;
}

/**
 * replace the sys_close syscall handler
 * if the fd is the one monitored by open, we will remove it
 **/
asmlinkage long rop_close(ulong fd){
	long ret = 0;
	CLOSE_FN fn = (CLOSE_FN)orig_close;
	ulong procid = current->pid;

	// call orignal handler
	ret = fn(fd);
	// remove the pair mapping record
	if( is_monitor_app_by_id(procid) ){
		//ROP_DB(printk(KERN_INFO "in the close handler fd %08ld\n", fd));
		remove_pair(get_app_slot(procid), fd);
	}
	return ret;
}

static void _rop_exit_group(void){
	ulong procid = current->pid;
	monitor_app_t *slot = get_app_slot(procid);
	if(slot != NULL){
		//ROP_DB(printk(KERN_INFO "in the exit_group handler application [%s]\n", current->comm));
		put_all_dbs(slot);
		free_app_slot(slot);
	}
}
/**
 * replace the sys_exit_group syscall handler
 * stop monitoring the target application
 **/
asmlinkage long rop_exit_group(ulong error){
	long ret = 0;
	EXIT_GROUP_FN fn = (EXIT_GROUP_FN)orig_exit_group;

	_rop_exit_group();
	// call orignal handler
	ret = fn(error);
	return ret;
}

/**
 * put the checking and pre-processing operations here
 * read the DB file for the monitored application
 * enable lbr services
 **/
static void noinline _rop_execve(const char __user *path){
	//ROP_DB(printk(KERN_INFO "in the execve handler %s\n", name ));
	char *filename = get_name_from_path(path);
	if(is_monitor_app(filename)){
		ulong procid = current->pid;		
		monitor_app_t* slot = get_app_slot(procid);
		mapping_element_t * ele = NULL;
		if(slot != NULL) return;
		slot = start_to_monitor_app(filename, procid);
		ele = insert_first_element(slot, filename);
		//printk(KERN_ERR "monitor app[%s], cr3 %08lx, pid %08x\n", filename, read_cr3(), current->pid);
		install_db(ele, filename);
	}
}

/**
 * replace the sys_execve syscall handler
 * start to monitor a program according to the policy
 * the execve is special, since this hanlder is not the one pointed by system call table
 * thus, we have to use ASM to directly jump back to the original one (keep stack the same)
 **/
asmlinkage long rop_execve(const char __user *path){
	ulong procid = current->pid;

	if(is_monitor_app_by_id(procid)){
		struct pt_regs *regs = (struct pt_regs*) &path;
		rop_check(procid, regs);
	}
	_rop_execve(path);
	__asm__(
			"xorl %%eax, %%eax \n"
			//"popl %%ebp \n"
			"leave \n"
			"jmp *%0\n"
			:
			:"m"(orig_execve)
		   );
	return 0;
}

static void build_app_mappings(monitor_app_t* slot, struct task_struct * task){
	struct mm_struct *mm = task->mm;
	struct vm_area_struct *list = mm->mmap, *ptr = list;
	__asm__ ("sti \n");
	do{
		struct file *fil = ptr->vm_file;
		if(fil != NULL){
			char* name = fil->f_path.dentry->d_iname;
			if(name != NULL){
				if( (ptr->vm_page_prot.pgprot == PAGE_COPY_EXECV) ){
					mapping_element_t *ptr_ele = insert_element(slot, ptr->vm_start, ptr->vm_end - ptr->vm_start);
					install_db(ptr_ele, name);
				}
			}
		} else {
			if(ptr->vm_page_prot.pgprot == PAGE_COPY_EXECV && ptr->vm_end - ptr->vm_start == PAGE_SIZE){
				mapping_element_t *ptr_ele = insert_element(slot, ptr->vm_start, ptr->vm_end - ptr->vm_start);
				install_db(ptr_ele, VDSO_NAME);
			}
		}
		ptr = ptr->vm_next;
		if(ptr == NULL) break;
	}while(ptr != list);
}

/**
 * replace the ptregs_clone syscall handler
 * start to monitor the child process of the monitored process
 * ptregs_clone in arch/x86/kernel/entry_32.S, it will call sys_clone in arch/x86/kernel/process.c
 **/
/*
739  Clone is an oddball.  The 4th arg is in %edi
740         ALIGN;
741 ptregs_clone:
742         CFI_STARTPROC
743         leal 4(%esp),%eax
744         pushl_cfi %eax		// fifth
745         pushl_cfi PT_EDI(%eax)	// fourth
746         movl PT_EDX(%eax),%ecx	// third
747         movl PT_ECX(%eax),%edx	// second
748         movl PT_EBX(%eax),%eax	// first argument
749         call sys_clone
750         addl $8,%esp
751         CFI_ADJUST_CFA_OFFSET -8
752         ret
753         CFI_ENDPROC
754 ENDPROC(ptregs_clone)
*/

static void monitor_child(long ret_pid){
	struct task_struct *task;
	if( is_monitor_app_by_id(current->pid) ){
		for_each_process(task)  
		{
			if( (task->pid > current->pid) && (!strcmp(task->comm, current->comm)) && (!is_monitor_app_by_id(task->pid)) ){
				monitor_app_t* slot = start_to_monitor_app(task->comm, task->pid);
				build_app_mappings(slot, current);
			}
		} 
	}
}

static ulong monitor_child_addr = (ulong)monitor_child;
asmlinkage long rop_clone_wrapper(unsigned long flags, void *child_stack, void *ptid, void *ctid, struct pt_regs *regs){
	__asm__ __volatile__(
			".global rop_clone\n"
			".align 4,0x90 \n"
			"rop_clone: \n"
			" leal 0x4(%%esp), %%eax \n"
			" pushl %%eax \n"
			// push PT_EDI(%%eax)
			" pushl 0x10(%%eax) \n"
			//" movl PT_EDX(%%eax), %%ecx \n"
			" movl 0x8(%%eax), %%ecx \n"
			//" movl PT_ECX(%%eax), %%edx \n"
			" movl 0x4(%%eax), %%edx \n"
			//" movl PT_EBX(%%eax), %%eax \n"
			" movl (%%eax), %%eax \n"
			" call *%0 \n"
			" addl $0x8, %%esp \n"
			" pushl %%eax \n"
			" call *%1 \n"
			" popl %%eax \n"
			" ret \n"
			:
			:"m"(orig_sys_clone), "m"(monitor_child_addr)
			:"%eax", "%ecx", "%edx"
			);
	return 0;
}

asmlinkage long rop_fork_wrapper(struct pt_regs *regs){
	// vfork is the same as the fork, the only difference is the sys_vfork address
	__asm__ __volatile__(
			".global rop_fork\n"
			".align 4,0x90 \n"
			"rop_fork: \n"
			// sys_fork(struct pt_regs *regs)
			// currently, the top of stack is the return IP
			" leal 0x4(%%esp), %%eax \n"
			" call *%0 \n"
			" pushl %%eax \n"
			" call *%1 \n"
			" popl %%eax \n"
			" ret \n"
			:
			:"m"(orig_sys_fork), "m"(monitor_child_addr)
			:"%eax", "%ecx", "%edx"
			);
	return 0;
}

/**
 * replace the original page_fault exception handler in the IDT
 * before call the original page fault handler, our NEW handler
 * check if the exception is due to our protection
 **/
void exp_irq_handlers( void ) {
	__asm__ (
			// in the page fault context, the stack contains
			// SS, ESP, EFLAGS, CS, EIP, ERROR_CODE
			".globl page_fault_14 \n"
			"page_fault_14: \n"
			// the handler (do_page_fault) address on the GS position
			" pushl %3 \n"
			" pushl %%fs \n"
			" pushl %%es \n"
			" pushl %%ds \n"
			" pushl %%eax \n"
			" pushl %%ebp \n"
			" pushl %%edi \n"
			" pushl %%esi \n"
			" pushl %%edx \n"
			" pushl %%ecx \n"
			" pushl %%ebx \n"
			" cld \n"
			" movl $0xd8, %%ecx \n"
			" movl %%ecx, %%fs \n"
			// before this, I skill the macro UNWIND_ESPFIX_STACK
			" movl %%ss, %%eax \n"
			" cmp  $0xd0, %%ax \n"
			" jne  27f \n"
			" movl $0x68, %%eax \n"
			" movl %%eax, %%ds \n"
			" movl %%eax, %%es \n"
			" movl %%fs:0xc083ea2c, %%ebx \n"
			" lea  -0x3f7c4000(%%ebx), %%ebx \n"
			" mov  0xd4(%%ebx),%%al \n"
			" mov  0xd7(%%ebx),%%ah \n"
			" shl   $0x10,%%eax \n"
			" addl  %%esp,%%eax \n"
			" pushl $0x68 \n"
			" pushl %%eax \n"
			" lss   (%%esp), %%esp \n"
			// since it is normally unused
			"27: \n"
			" movl %%gs, %%ecx \n"
			// the 0x28(%esp) is the handler address
			" movl 0x28(%%esp), %%edi \n"
			// the 0x2c(%esp) is the orig_eax
			" movl 0x2c(%%esp), %%edx \n"
			// make sure no system call to restart
			" movl $-1, 0x2c(%%esp) \n"
			// save the gs to the GS position in the frame
			" movl %%ecx, 0x28(%%esp) \n"
			// adjust gs, ds, es
			" movl $0xe0, %%ecx \n"
			" movl %%ecx, %%gs \n"
			" movl $0x7b, %%ecx \n"
			" movl %%ecx, %%ds \n"
			" movl %%ecx, %%es \n"
			// backup kernel stack ESP position
			" movl %%esp, %0 \n"
			" movl %%edx, %1 \n"
			" movl %0, %%eax \n"
			// ----call pre-handler---------
			" call *%2 \n"
			// -----------------------------
			// we must make sure the EAX point to the Regs_frame
			// and the EDX contains the error_code
			" movl %1, %%edx \n"
			" movl %%esp, %%eax \n"
			// call original handler
			" call *%3 \n"
			" movl %1, %%edx \n"
			" movl %%esp, %%eax \n"
			" pushl %4 \n"
			// jump to post-handler
			" jmp *%5 \n"
			:"=m"(g_exp_irq_esp), "=m"(g_error_code)
			:"m"(pre_handle_exception_code), "m"(orig_do_page_fault), "m"(orig_ret_from_exception), "m"(post_handle_exception_code)
				 );
}

/**
 * tool function, to install syscall handler in the syscall table
 **/
static ulong install_syscall_handler(ulong index, ulong handler_addr){
	unsigned long cr0, orig_handler;
	ulong *table = (ulong*)orig_sys_call_table;

	cr0 = readcr0();
	write_cr0(cr0 & ~X86_CR0_WP);

	/* replace the syscall handler to the new one */
	orig_handler = *(table + index);
	*(table + index) = handler_addr;

	// change back, to enforce read-only
	writecr0(cr0); 
	return orig_handler;
}

/**
 * get syscall handler, read from the syscall table
 **/
static inline ulong get_syscall_handler(ulong index){
	ulong *table = (ulong*)orig_sys_call_table;
	return *(table + index);
}

// get the original handler by analyzing the idt table
static inline ulong get_orig_handler_addr ( gate_desc* orig_idt, ulong irq ) {
	ulong orig_addr = 0;
	gate_desc item = orig_idt[irq];
	orig_addr += ( ( item.a & 0xffff ) + ( item.b & 0xffff0000 ) );
	return orig_addr;
}

static inline void print_idt(gate_desc* idt){
	int i = 0;
	for ( i = 0; i < 32; ++i ){
		ROP_DB(printk(KERN_INFO "idt[%d] %08x %08x, handler %lx\n",
					i, idt[i].a, idt[i].b, get_orig_handler_addr(idt, i) ));
	}
	ROP_DB(printk(KERN_INFO "idt[0x80] %08x %08x, handler %lx\n",
				idt[0x80].a, idt[0x80].b, get_orig_handler_addr(idt, 0x80) ));
}

/**
 * replace the page_fault exception handler
 * replace intercepted syscalls, i.e., mmap2, mprotect
 **/
void kern_trap_init(void)
{
	// save the original page_fault_handler
	orig_page_fault = get_orig_handler_addr((gate_desc*)orig_idt_table, 14);
	kern_set_intr_gate(14, &page_fault_14);
	// replace the syscall handler (mprotect, mmap2, munmap, execve)
	orig_mprotect = install_syscall_handler (__NR_mprotect, (ulong)rop_mprotect);
	orig_mmap2 = install_syscall_handler (__NR_mmap2, (ulong)rop_mmap2);
	orig_munmap = install_syscall_handler (__NR_munmap, (ulong)rop_munmap);
	orig_execve = install_syscall_handler (__NR_execve, (ulong)rop_execve);
	// arch/x86/kernel/entry_32.S ptregs_clone
	orig_clone = install_syscall_handler (__NR_clone, (ulong)rop_clone);
	orig_fork = install_syscall_handler (__NR_fork, (ulong)rop_fork);
	orig_open = install_syscall_handler (__NR_open, (ulong)rop_open);
	orig_close = install_syscall_handler (__NR_close, (ulong)rop_close);
	orig_exit_group = install_syscall_handler (__NR_exit_group, (ulong)rop_exit_group);
}

/**
 * restore the IDT and syscall table
 **/
void kern_trap_exit(void){
	kern_set_intr_gate(14, (void*)orig_page_fault);
	install_syscall_handler (__NR_mprotect, (ulong)orig_mprotect);
	install_syscall_handler (__NR_mmap2, (ulong)orig_mmap2);
	install_syscall_handler (__NR_munmap, (ulong)orig_munmap);
	install_syscall_handler (__NR_execve, (ulong)orig_execve);
	install_syscall_handler (__NR_clone, (ulong)orig_clone);
	install_syscall_handler (__NR_fork, (ulong)orig_fork);
	install_syscall_handler (__NR_open, (ulong)orig_open);
	install_syscall_handler (__NR_close, (ulong)orig_close);
	install_syscall_handler (__NR_exit_group, (ulong)orig_exit_group);
	__flush_tlb_all();
}

/*
 * Page fault error code bits:
 *
 *   bit 0 ==	 0: no page found		1: protection fault
 *   bit 1 ==	 0: read access			1: write access
 *   bit 2 ==	 0: kernel-mode access	1: user-mode access
 *   bit 3 ==							1: use of reserved bit detected
 *   bit 4 ==							1: fault was an instruction fetch
 */
enum x86_pf_error_code {

	PF_PROT		=		1 << 0,
	PF_WRITE	=		1 << 1,
	PF_USER		=		1 << 2,
	PF_RSVD		=		1 << 3,
	PF_INSTR	=		1 << 4,
};

/* Added by Zongwei Zhou
 * Use fromip to fast filtering no-gadget case */
long find_past_payload(ulong procid, ulong *fromip, ulong *toip, ulong pos){
	long i = 0, count = 0, status = 0, extra = 0;
	char fast_byte=0x0, sip=0xff;
	monitor_app_t *slot = get_app_slot(procid);
	mapping_element_t *ele = 0;

	for(; i < ROP_LBR_CHECKING_NUM + extra; ++i){
		int index = (pos + MAX_BRANCH_NUM - i) % MAX_BRANCH_NUM;
		//printk(KERN_ERR "from[%d]: %08lx -> to[%d]: %08lx\n", index, fromip[index], index, toip[index]);
		// if the source addr is from kernel space, direct return
		if(fromip[index] >= KERNEL_SPACE_BOUNDARY){
			// skip our own #PF exception record in LBR
			if(fromip[index] >= (ulong)rop_open) {
				extra ++; continue;
			}
			break;
		}
		if(toip[index] == 0) break;

		/* Added by Zongwei Zhou: read one byte *(fromip[index]), if FF, ijmp, otherwise, no gadget */
		copy_from_user(&fast_byte,(void *)(fromip[index]),1);
		if (i==0) {
			sip = fast_byte;
			continue; // skip the first ip pair
		}
		/* 0xff means indirect call/jmp, 0xc* represents ret */
		if (sip==0xff || sip==0xc2 || sip==0xc3 || sip==0xca || sip==0xcb ) { 
			sip = fast_byte;

			ele = get_lib_mapping(slot, toip[index]);
			// if ele is NULL, that means it is not a gadget
			if(ele == NULL) { break; }

			// read the table, get the state
			status = get_status_val(ele, toip[index] - ele->start);
			switch(status){
				case ALIGNED_NO_BRANCH:
				case ALIGNED_SJMP:
					goto out;
				case UNALIGNED_INSTRUCTION:
					if(check_is_gadget((void*)toip[index])){
						printk(KERN_ERR "unaligned ip %08lx, start %08lx, offset %08lx\n", toip[index], ele->start, toip[index]-ele->start);
						count = ROP_GADGET_CHAIN_LENGTH;
					} else {
						set_status_val(ele, toip[index] - ele->start, 0);
					}
					goto out;
				default:
					count ++;
					if(count == ROP_GADGET_CHAIN_LENGTH){
						//printk(KERN_ERR "get rop chain in LBR\n");
						goto out;
					}
			}
		} else {
			/* Added by Zongwei Zhou: if last fromip is not ijmp, stop LBR checking 
			 * currently we haven't checked the alignment of fromip */
			goto out;
		}
	}
out:
	return count;
}

long quickly_rop_checking(ulong procid, ulong *fromip, ulong *toip, ulong pos){
	long i = 0, count = 0, status = 0, extra = 0;
	monitor_app_t *slot = get_app_slot(procid);
	mapping_element_t *ele = 0;

	for(; i < ROP_LBR_CHECKING_NUM + extra; ++i){
		int index = (pos + MAX_BRANCH_NUM - i) % MAX_BRANCH_NUM;
		//printk(KERN_ERR "from[%d]: %08lx -> to[%d]: %08lx\n", index, fromip[index], index, toip[index]);
		// if the source addr is from kernel space, direct return
		if(fromip[index] >= KERNEL_SPACE_BOUNDARY){
			// skip our own #PF exception record in LBR
			if(fromip[index] >= (ulong)rop_open) {
				extra ++; continue;
			}
			break;
		}
		if(toip[index] == 0) break;
		ele = get_lib_mapping(slot, toip[index]);
		// if ele is NULL, that means it is not a gadget
		if(ele == NULL) { break; }

		// read the table, get the state
		status = get_status_val(ele, toip[index] - ele->start);
		switch(status){
			case ALIGNED_NO_BRANCH:
			case ALIGNED_SJMP:
				goto out;
			case UNALIGNED_INSTRUCTION:
				if(check_is_gadget((void*)toip[index])){
					//printk(KERN_ERR "unaligned ip %08lx, start %08lx, offset %08lx\n", toip[index], ele->start, toip[index]-ele->start);
					count = ROP_GADGET_CHAIN_LENGTH;
				} else {
					set_status_val(ele, toip[index] - ele->start, 0);
				}
				goto out;
			default:
				count ++;
		}
	}
out:
	return count;
}

// this definiation will be removed once Miao finish the real one.
// this is only an example
#define INDIRECT_JUMP					(0x2)

/**
 * get the instruction type, by looking up the table
 **/
int get_instruction_type(mapping_element_t *ele, ulong eip){
	// query the status using offset
	int status = get_status_val(ele, eip - ele->start);
	if(status == ALIGNED_RET || status == ALIGNED_IJMP) return INDIRECT_JUMP;
	return 0;
}
/**
 * emulate the gadget
 * first identify the relationship between the current context with gadget
 * return 0 if the emulation is OK, otherwise return -1
 **/
static int emulate_gadget(mapping_element_t *ele, struct rop_emulate_ctxt* ctxt){
	while(1){
		if(ctxt->ctxt->regs->eip >= KERNEL_SPACE_BOUNDARY || ctxt->ctxt->regs->esp >= KERNEL_SPACE_BOUNDARY) return -1;
		if(get_instruction_type(ele, ctxt->ctxt->regs->eip) == INDIRECT_JUMP){
			if(x86_ins_emulate(ctxt) != X86EMUL_OKAY) {
				return -1;
			}
			break;
		}
		if(x86_ins_emulate(ctxt) != X86EMUL_OKAY) {
			return -1;
		}
	}
	return 0;
}

/**
 * emulate all gadgets, from the first unemulated gadget, to the latest one
 **/
static int emulate_gadget_chain(monitor_app_t *slot, ulong gadget, struct rop_emulate_ctxt* ctxt, gadget_cache_p chain){
	int i = 0;
	do{
		if(chain->gadgets[i].is_emulated == 0){
			mapping_element_t *ele = get_lib_mapping(slot, chain->gadgets[i].start);
			if(ele == NULL){
				printk(KERN_ERR "mapping query failed\n");
				return -1;
			}
			if(emulate_gadget(ele, ctxt)){
				//printk(KERN_ERR "emulation failed eip %08x\n", ctxt->ctxt->regs->eip);
				return -1;
			}
			chain->gadgets[i].is_emulated = 1;
		}
		i++;
	} while(i <= chain->index);
	return 0;
}

/**
 * get the destination of the gadget
 * update the ESP position
 * cache the des, ESP, IS_EMUL for emulation
 **/
ulong get_destination(monitor_app_t *slot, ulong gadget, ulong status, 
		ulong *esp_ptr, struct rop_emulate_ctxt* ctxt, gadget_cache_p chain){
	ulong des_val = 0, esp_offset = 0;
	switch(status){
		// ret, get the top value of stack, 0010
		case ALIGNED_RET:
			des_val = *(ulong*)(*esp_ptr);
			// update stack and get the new des value
			*esp_ptr = *esp_ptr + 4;
			break;
		// we have to emulate the whole gadget (cal/jmp *), 0011
		case ALIGNED_IJMP:
		// gadget contains stack pivoting, emulate it, 0100
		case ALIGNED_STACK_PIVOT:
			//printk(KERN_ERR "start to emulate eip %08x\n", ctxt->regs->eip);

#ifdef MICRO_BENCHMARK
			start2 = __native_read_tsc();
#endif

			if(emulate_gadget_chain(slot, gadget, ctxt, chain) != -1){
				*esp_ptr = ctxt->ctxt->regs->esp;
				des_val = ctxt->ctxt->regs->eip;
			} else {
				des_val = 0;
			}

#ifdef MICRO_BENCHMARK
            end2 = __native_read_tsc();
			printk(KERN_ERR "EmuT %lld", (end2 - start2));
#endif
			break;
		// known des value in the stack
		default:
			// get the offset according to the table, the first one is 0101
			esp_offset = (status - 4) * 4;
			// update stack and get the new des value
			*esp_ptr = *esp_ptr + esp_offset;
			des_val = *(ulong*)(*esp_ptr - 4);

	}
	return des_val;
}

/**
 * find future execution flow
 * if it is a gadget chain, ROP is detected
 * else there is no ROP
 **/
long find_future_payload(ulong procid, ulong des, ulong max_num, struct pt_regs *regs){
	long i = 0, count = 0, status = 0;
	// the init values of destination and ESP
	ulong next_des = des, esp = regs->sp;
	monitor_app_t *slot = get_app_slot(procid);
	mapping_element_t *ele = 0;
	// this is for caching the gadget chain to assist the emulation
	gadget_cache_t gadget_chain;

	// set oontext for the first future gadget
	set_context(slot->ctxt, regs);
	//gadget_chain.index = 0;
	memset(&gadget_chain, 0, sizeof(gadget_chain));
	//printk(KERN_ERR "next_dex %08lx, eip %08lx, cr2 %08lx\n", next_des, regs->ip, read_cr2());

	for(i = 0; i < max_num; ++i){
		if(next_des == 0) break;
		ele = get_lib_mapping(slot, next_des);
		if(ele == NULL) break;
		if(next_des >= KERNEL_SPACE_BOUNDARY) break;
		status = get_status_val(ele, next_des - ele->start);
		switch(status){
			case ALIGNED_NO_BRANCH:
			case ALIGNED_SJMP:
				goto out;
			case UNALIGNED_INSTRUCTION:
				if(check_is_gadget((void*)next_des)){
						count = ROP_GADGET_CHAIN_LENGTH;
				} else {
					set_status_val(ele, next_des - ele->start, 0);
				}
				goto out;
			default:
				gadget_chain.gadgets[gadget_chain.index].start = next_des;
				gadget_chain.gadgets[gadget_chain.index].esp= esp;
				// gadget, update the counter, get next des addr
				next_des = get_destination(slot, next_des, status, &esp, slot->ctxt, &gadget_chain);
				gadget_chain.index ++;
				// update the counter to show we get a new gadget
				count ++;
		}
	}
out:
	clear_context(slot->ctxt);
	return count;
}

/**
 * check past execution trace and future execution flow
 * if get a gadget chain, return 1
 * else return 0 to indicate no ROP
 *
 * Modified by Zongwei Zhou to add use find_past_payload()
 **/
long rop_check2(ulong procid, struct pt_regs *regs){
	ulong fromip[16] = {0}, toip[16] = {0};
	long pos = 0, count_lbr = 0, count_emul = 0;

	pos = get_lbr_position();
	get_ip_pairs(fromip, toip, 0, MAX_BRANCH_NUM);

#ifdef MICRO_BENCHMARK
	start = __native_read_tsc();
#endif
	count_lbr = find_past_payload(procid, fromip, toip, pos);
#ifdef MICRO_BENCHMARK
	end = __native_read_tsc();
#endif
	if(count_lbr == ROP_GADGET_CHAIN_LENGTH){
		//printk(KERN_ERR "get rop chain in LBR\n");
		return 1;
	}

#ifdef MICRO_BENCHMARK
	start3 = __native_read_tsc();
#endif
	count_emul = find_future_payload(procid, toip[pos], ROP_GADGET_CHAIN_LENGTH - count_lbr+1, regs);
#ifdef MICRO_BENCHMARK
	end3 = __native_read_tsc();
	printk(KERN_ERR "LBRT %lld PayloadT: %lld EmuCtr: %ld\n", (end - start), (end3 - start3), count_emul);
#endif

	if((count_lbr + count_emul) >= ROP_GADGET_CHAIN_LENGTH){
		//printk(KERN_ERR "get rop chain, eip %08lx, lbr %ld emul %ld\n", regs->ip, count_lbr, count_emul);
		return 1;
	}
	return 0;
}

/**
 * check past execution trace and future execution flow
 * if get a gadget chain, return 1
 * else return 0 to indicate no ROP
 **/
long rop_check1(ulong procid, struct pt_regs *regs){
	ulong fromip[16] = {0}, toip[16] = {0};
	long pos = 0, count_lbr = 0, count_emul = 0;

	pos = get_lbr_position();
	get_ip_pairs(fromip, toip, 0, MAX_BRANCH_NUM);

	count_lbr = quickly_rop_checking(procid, fromip, toip, pos);
	// if count is 0, meaning that there is no gadget chain
	if(count_lbr <= 1) return 0;
	if(count_lbr == ROP_GADGET_CHAIN_LENGTH){
		//printk(KERN_ERR "get rop chain in LBR\n");
		return 1;
	}
	count_emul = find_future_payload(procid, toip[pos], ROP_GADGET_CHAIN_LENGTH - count_lbr+1, regs);
	if((count_lbr + count_emul) > ROP_GADGET_CHAIN_LENGTH){
		/* FIXME */
		//printk(KERN_ERR "get rop chain, eip %08lx, lbr %ld emul %ld\n", regs->ip, count_lbr, count_emul);
		return 1;
	}
	return 0;
}

#define NEW_ROP_CHECK
long rop_check(ulong procid, struct pt_regs *regs){
	long ret;
#ifdef NEW_ROP_CHECK
	ret = rop_check2(procid, regs);
#else
	ret = rop_check1(procid, regs);
#endif
	return ret;
}

static inline void print_app_slot(void){
	int i = 0; 
	for(i = 0; i < MAX_MONITOR_NUM; i ++){
		if(apps[i].procid != 0){
			printk(KERN_ERR "apps[%d] name %s, procid %ld\n", i, apps[i].name, apps[i].procid);
		}
	}
}


/**
 * check if the PF exception is introduced by the monitor window
 * If it is, we need handle the exception and directly return without going through the PF exception procedure
 **/
static noinline int is_caused_by_monitor(struct pt_regs* regs, ulong error_code){
	ulong procid = current->pid;
	const static ulong monwin_error_code = (PF_INSTR|PF_USER|PF_PROT);
	monitor_app_t *slot = NULL;
	// if instruction fetch exception
	if( error_code == monwin_error_code && regs->ip < KERNEL_SPACE_BOUNDARY ){
		if( ! is_monitor_app_by_id(procid) ){
			//printk(KERN_ERR "the current[%s] %d, real parent %d, parent %d\n", current->comm, current->pid, current->real_parent->pid, current->parent->pid);
			slot = start_to_monitor_app(current->comm, current->pid);
			build_app_mappings(slot, current);
		} else {
			slot = get_app_slot(procid);
		}
		// error_code 0x14 (PF_INSTR|PF_USER) for the normal mmaped code page
		// error_code 0x15 (PF_INSTR|PF_USER|PF_PROT) for the monitor window
		//
		// protection-based exception, P bits should be set already
		// sometimes, the regs->ip != cr2 (instruction fetching, cross the page-boundary)


		// restore the page executable, update the data structure to record the new page
		// if is necessary, we should update the monitor window by replacing certain page
		force_enqueue(&slot->monwin, read_cr2());
		//get_and_print_lbr();
		rop_check(procid, regs);
		//printk(KERN_ERR "monwin error_code %08lx, EIP %08lx, CR2 %08lx, PTE %16llx\n", error_code, regs->ip, read_cr2(), get_pte_value(current->mm, read_cr2()));
		// here, we should verify if the execution is legal (ROP?)
		return 1;
	}
	return 0;
}

/**
 * the definition of the following function is from the do_page_fault in
 * arch/x86/mm/fault.c
 * when I try void pre_handle_exception(struct pt_regs *regs), the system will crash
 **/
dotraplinkage void __kprobes pre_handle_exception ( struct pt_regs* regs, ulong error_code) {
	// add our handler to handle fetching-instruction error 
	// P:	0 fault was caused by a non-present page, 1 the fualt by a page-level protection violation
	// W/R	0 caused by read,	1 caused by write
	// U/S	0 not in user mode (CPL<3)	1 in user mode
	// RSVD
	// I/D	0 not instruction fetch, 1 caused by instruction fetch  

	if(is_caused_by_monitor(regs, error_code)){
		// we need to directly return, rather than going through the original PF handler
		__asm__(
				// adjust the ebp
				//"popl %%ebp \n"
				"leave \n"
				// pop the EIP, and set the EAX to 0
				"popl %%eax \n"
				"xorl %%eax, %%eax \n"
				// RESTORE_ALL
				" popl %%ebx \n"
				" popl %%ecx \n"
				" popl %%edx \n"
				" popl %%esi \n"
				" popl %%edi \n"
				" popl %%ebp \n"
				" popl %%eax \n"
				" popl %%ds \n"
				" popl %%es \n"
				" popl %%fs \n"
				" popl %%gs \n"
				" addl $4, %%esp \n"
				" sti \n"
				// interrupt_return
				" iret \n"
				//"jmp *%0\n"
				:
				:"m"(orig_ret_from_exception)
			   );
	}
	return;
}

#define FIREFOX_NAME						"firefox"
#define APACHE_NAME							"apache2"

static void find_vdso_ld(ulong procid, monitor_app_t* slot, struct task_struct * task){
	struct mm_struct *mm = task->mm;
	struct vm_area_struct *list = mm->mmap, *ptr = list;
	do{
		struct file *fil = ptr->vm_file;
		if(fil != NULL){
			char* name = fil->f_path.dentry->d_iname;
			if(name != NULL){
				if( !strcmp(name, LD_NAME) && (ptr->vm_page_prot.pgprot == PAGE_COPY_EXECV) ){
					mapping_element_t *ptr_ele = insert_element(slot, ptr->vm_start, ptr->vm_end - ptr->vm_start);
					install_db(ptr_ele, name);
					//printk(KERN_INFO "mmaped file [%s], prot %16llx, start %08lx, end %08lx\n", 
					//		name, ptr->vm_page_prot.pgprot, ptr->vm_start, ptr->vm_end);
				}
				if( !strcmp(name, APACHE_NAME) && (ptr->vm_page_prot.pgprot == PAGE_COPY_EXECV) ){
					mapping_element_t *ptr_ele = insert_element(slot, ptr->vm_start, ptr->vm_end - ptr->vm_start);
					install_db(ptr_ele, name);
				}
				if( !strcmp(name, FIREFOX_NAME) && (ptr->vm_page_prot.pgprot == PAGE_COPY_EXECV) ){
					mapping_element_t *ptr_ele = insert_element(slot, ptr->vm_start, ptr->vm_end - ptr->vm_start);
					install_db(ptr_ele, name);
				}
			}
		} else {
			if(ptr->vm_page_prot.pgprot == PAGE_COPY_EXECV && ptr->vm_end - ptr->vm_start == PAGE_SIZE){
				mapping_element_t *ptr_ele = insert_element(slot, ptr->vm_start, ptr->vm_end - ptr->vm_start);
				install_db(ptr_ele, VDSO_NAME);
				//printk(KERN_INFO "no mmaped file, prot %16llx, start, %08lx, end %08lx\n",
				//		ptr->vm_page_prot.pgprot, ptr->vm_start, ptr->vm_end);
			}
		}
		ptr = ptr->vm_next;
		if(ptr == NULL) break;
	}while(ptr != list);
}

dotraplinkage void __kprobes post_handle_exception ( struct pt_regs* regs, ulong error_code) {
	ulong procid = current->pid;
	const static ulong ins_error_code = (PF_INSTR|PF_USER);
	// if instruction fetch exception
	if( is_monitor_app_by_id(procid) ){
		monitor_app_t *slot = get_app_slot(procid);
		if(error_code == ins_error_code && regs->ip < KERNEL_SPACE_BOUNDARY){
			// restore the page executable, update the data structure to record the new page
			// if is necessary, we should update the monitor window by replacing certain page
			force_enqueue(&slot->monwin, read_cr2());
			// record this new code page, later we should restore the exectuable right when the monitor window is disabled
			record_code_page(&slot->monwin, read_cr2());

			if(slot->monitor_flag == MONITOR_DISABLED){
				enable_lbr();
				lbr_userspace();
				// find LD and VDSO by parsing the VMA list
				find_vdso_ld(procid, slot, current);
				slot->monitor_flag = MONITOR_START_POINT;
			}
		}
		// kernel read user space, and the page does not exist in the memory
		if(error_code == 0){ 
			if(get_lib_mapping(slot, read_cr2()) != NULL){
				//printk(KERN_ERR "ip %08lx, addr %08lx\n", regs->ip, read_cr2());
				set_nx_on_page(&slot->monwin, read_cr2());
				record_code_page(&slot->monwin, read_cr2());
			}
		}
	}
	return;
}
/**
 *	the intialization of the IDT for exception and interrupt
 *	allocate space for IDT, and prepare the fake handlers
 **/
int pagefault_syscall_init(void){
	/*
	   ROP_DB(printk(KERN_INFO " the sys_execve[%d] handler address %08lx\n", __NR_execve, get_syscall_handler(__NR_execve)));
	   ROP_DB(printk(KERN_INFO " the sys_mmap2[%d] handler address %08lx\n", __NR_mmap2, get_syscall_handler(__NR_mmap2)));
	   ROP_DB(printk(KERN_INFO " the sys_munmap[%d] handler address %08lx\n", __NR_munmap, get_syscall_handler(__NR_munmap)));
	   ROP_DB(printk(KERN_INFO " the sys_mprotect[%d] handler address %08lx\n", __NR_mprotect, get_syscall_handler(__NR_mprotect)));
	   */
	// replace the page-fault handler
	kern_trap_init();
	// init monitor app list
	init_monitor_app_list();
	return 0;
}

static inline int ht_code_regions_test(void)
{
	struct task_struct *task;  
	const char *tname = "ht";
	for_each_process(task)  
	{
		if(!strcmp(task->comm, tname)){
			ulong cr3 = ( (ulong)__phys_addr(task->mm->pgd) - 0xc0000000);
			printk(KERN_INFO "the application %s, cr3 %08lx, pid %08x\n", task->comm, cr3, task->pid); 
		}
	} 
	return 0;
}

/**
 *	the destructor for the interception of interrupt/exceptions
 *	deallocate memory space
 *	release all DBs
 *	disable LBR services
 **/
void pagefault_syscall_exit(void){
	kern_trap_exit();
	release_all_dbs();
	free_all_apps();
	disable_lbr();
	//ht_code_regions_test();
}

/* 
 * Initialize the module - Register the character device 
 */
static int __init rop_module_init(void)
{
	pagefault_syscall_init();
	printk(KERN_ERR "***********install_syscall_handler (init) addr %08lx *************\n", (ulong)install_syscall_handler);
	return 0;
}

/* 
 * Cleanup - unregister the appropriate file from /proc 
 */
static void __exit rop_module_exit(void)
{
	pagefault_syscall_exit();
	printk(KERN_ERR "#########rop_module_exit (exit) addr %08lx #########\n", (ulong)rop_module_exit);
}

/* Let the kernel know the calls for module init and exit */
module_init(rop_module_init);
module_exit(rop_module_exit);
MODULE_LICENSE("GPL");

